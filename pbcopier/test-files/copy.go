// AUTOMAGICALLY GENERATED by mkpbcopy --- DO NOT EDIT

package test

func (in *Base) DeepCopy() *Base {
	out := &Base{}
	out.Bit = in.Bit
	out.Smallint = in.Smallint
	out.Largeint = in.Largeint
	out.Smallfloat = in.Smallfloat
	out.Largefloat = in.Largefloat
	if len(in.Text) > 0 {
		out.Text = in.Text
	}
	if in.Child != nil {
		out.Child = in.Child.DeepCopy()
	}
	out.Onoff = in.Onoff
	if in.Optbit != nil {
		out.Optbit = in.Optbit
	}
	if in.Optsmallint != nil {
		out.Optsmallint = in.Optsmallint
	}
	if in.Optlargeint != nil {
		out.Optlargeint = in.Optlargeint
	}
	if in.Optsmallfloat != nil {
		out.Optsmallfloat = in.Optsmallfloat
	}
	if in.Optlargefloat != nil {
		out.Optlargefloat = in.Optlargefloat
	}
	if in.Opttext != nil {
		out.Opttext = in.Opttext
	}
	if in.Optchild != nil {
		out.Optchild = in.Optchild.DeepCopy()
	}
	if in.Optonoff != nil {
		out.Optonoff = in.Optonoff
	}
	if in.Listbit != nil {
		if len(in.Listbit) > 0 {
			out.Listbit = make([]bool, len(in.Listbit))
			for i, v := range in.Listbit {
				out.Listbit[i] = v
			}
		}
	}
	if in.Listsmallint != nil {
		if len(in.Listsmallint) > 0 {
			out.Listsmallint = make([]int32, len(in.Listsmallint))
			for i, v := range in.Listsmallint {
				out.Listsmallint[i] = v
			}
		}
	}
	if in.Listlargeint != nil {
		if len(in.Listlargeint) > 0 {
			out.Listlargeint = make([]int64, len(in.Listlargeint))
			for i, v := range in.Listlargeint {
				out.Listlargeint[i] = v
			}
		}
	}
	if in.Listsmallfloat != nil {
		if len(in.Listsmallfloat) > 0 {
			out.Listsmallfloat = make([]float32, len(in.Listsmallfloat))
			for i, v := range in.Listsmallfloat {
				out.Listsmallfloat[i] = v
			}
		}
	}
	if in.Listlargefloat != nil {
		if len(in.Listlargefloat) > 0 {
			out.Listlargefloat = make([]float64, len(in.Listlargefloat))
			for i, v := range in.Listlargefloat {
				out.Listlargefloat[i] = v
			}
		}
	}
	if in.Listtext != nil {
		if len(in.Listtext) > 0 {
			out.Listtext = make([]string, len(in.Listtext))
			for i, v := range in.Listtext {
				out.Listtext[i] = v
			}
		}
	}
	if in.Listchild != nil {
		if len(in.Listchild) > 0 {
			out.Listchild = make([]*Child, len(in.Listchild))
			for i, v := range in.Listchild {
				out.Listchild[i] = v.DeepCopy()
			}
		}
	}
	if in.Listonoff != nil {
		if len(in.Listonoff) > 0 {
			out.Listonoff = make([]Base_OnOff, len(in.Listonoff))
			for i, v := range in.Listonoff {
				out.Listonoff[i] = v
			}
		}
	}
	if in.Maptbit != nil {
		out.Maptbit = make(map[bool]bool, len(in.Maptbit))
		for k, v := range in.Maptbit {
			out.Maptbit[k] = v
		}
	}
	if in.Mapsmallint != nil {
		out.Mapsmallint = make(map[int32]int32, len(in.Mapsmallint))
		for k, v := range in.Mapsmallint {
			out.Mapsmallint[k] = v
		}
	}
	if in.Maplargeint != nil {
		out.Maplargeint = make(map[int64]int64, len(in.Maplargeint))
		for k, v := range in.Maplargeint {
			out.Maplargeint[k] = v
		}
	}
	if in.Maptext != nil {
		out.Maptext = make(map[string]string, len(in.Maptext))
		for k, v := range in.Maptext {
			out.Maptext[k] = v
		}
	}
	if in.Mapchild != nil {
		out.Mapchild = make(map[string]*Child, len(in.Mapchild))
		for k, v := range in.Mapchild {
			out.Mapchild[k] = v.DeepCopy()
		}
	}
	return out
}

func (in *Base) ShallowCopy() *Base {
	out := &Base{}
	out.Bit = in.Bit
	out.Smallint = in.Smallint
	out.Largeint = in.Largeint
	out.Smallfloat = in.Smallfloat
	out.Largefloat = in.Largefloat
	out.Text = in.Text
	out.Child = in.Child
	out.Onoff = in.Onoff
	out.Optbit = in.Optbit
	out.Optsmallint = in.Optsmallint
	out.Optlargeint = in.Optlargeint
	out.Optsmallfloat = in.Optsmallfloat
	out.Optlargefloat = in.Optlargefloat
	out.Opttext = in.Opttext
	out.Optchild = in.Optchild
	out.Optonoff = in.Optonoff
	out.Listbit = in.Listbit
	out.Listsmallint = in.Listsmallint
	out.Listlargeint = in.Listlargeint
	out.Listsmallfloat = in.Listsmallfloat
	out.Listlargefloat = in.Listlargefloat
	out.Listtext = in.Listtext
	out.Listchild = in.Listchild
	out.Listonoff = in.Listonoff
	out.Maptbit = in.Maptbit
	out.Mapsmallint = in.Mapsmallint
	out.Maplargeint = in.Maplargeint
	out.Maptext = in.Maptext
	out.Mapchild = in.Mapchild
	return out
}

func (in *Child) DeepCopy() *Child {
	out := &Child{}
	if len(in.Kids) > 0 {
		out.Kids = in.Kids
	}
	return out
}

func (in *Child) ShallowCopy() *Child {
	out := &Child{}
	out.Kids = in.Kids
	return out
}

