package pbcopier

import (
	"fmt"
	"os"
	"sort"
	"strings"
)

// PbReader reads pb.go file
type PbReader struct {
	lines []string
}

func NewPbReader(pbgo string) (*PbReader, error) {
	contents, err := os.ReadFile(pbgo)
	if err != nil {
		return nil, fmt.Errorf("Can not open %s: %s\n", pbgo, err)
	}
	lines := strings.Replace(string(contents), "\t", " ", -1)
	return &PbReader{
		lines: strings.Split(lines, "\n"),
	}, nil
}

func (pb *PbReader) FindPackage() (string, error) {
	for _, line := range pb.lines {
		if strings.HasPrefix(line, "package") {
			return strings.Trim(line[8:], " "), nil
		}
	}
	return "", fmt.Errorf("Could not find package name")
}

func (pb *PbReader) FindStruct(structName string) (int, error) {
	structDef := fmt.Sprintf("type %s struct {", structName)
	for idx, line := range pb.lines {
		if strings.HasPrefix(line, structDef) {
			return idx, nil
		}
	}
	return 0, fmt.Errorf("Could not find struct definition for %s", structName)
}

func (pb *PbReader) FindType(typeName string) string {
	typeDef := fmt.Sprintf("type %s ", typeName)
	for _, line := range pb.lines {
		if strings.HasPrefix(line, typeDef) {
			return strings.Split(line, " ")[2]
		}
	}
	return ""
}

func (pb *PbReader) NextField(startIdx int) (*PbField, int, error) {
	maxIdx := len(pb.lines)
	startIdx++
	for idx := startIdx; idx < maxIdx; idx++ {
		line := pb.lines[idx]
		if strings.HasPrefix(line, "}") {
			break
		}
		q := strings.Index(line, "`")
		if q < 0 {
			continue
		}
		line = line[:q]
		line = strings.Trim(line, " ")
		sl := strings.SplitN(line, " ", 2)
		if len(sl) != 2 {
			return nil, -1, fmt.Errorf("Could not parse %s", pb.lines[idx])
		}
		memberName := strings.Trim(sl[0], " ")
		memberType := strings.Trim(sl[1], " ")

		return MakeField(memberName, memberType), idx, nil
	}
	return nil, -1, nil
}

// PbWriter generages copy.go file
type PbWriter struct {
	fp          *os.File
	methods     map[string]*PbMethod
	packageName string
}

func NewPbWriter(filename string, packageName string) (*PbWriter, error) {
	fp, err := os.OpenFile(filename, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0664)
	if err != nil {
		return nil, fmt.Errorf("Can not open %s: %s\n", filename, err)
	}

	return &PbWriter{
		fp:          fp,
		methods:     make(map[string]*PbMethod),
		packageName: packageName,
	}, nil
}

func (pb *PbWriter) HasMethod(structName string) bool {
	_, ok := pb.methods[structName]
	return ok
}

func (pb *PbWriter) NewMethod(structName string) *PbMethod {
	pbMethod := &PbMethod{
		structName: structName,
	}
	pb.methods[structName] = pbMethod
	return pbMethod
}

func (pb *PbWriter) Flush() error {
	sb := &strings.Builder{}
	sb.Grow(10240)

	pb.writeHeader(sb)

	// write in aplpha order here
	methods := pb.sortedMethods()
	for _, method := range methods {
		pb.methods[method].Write(sb)
	}

	_, err := pb.fp.Write([]byte(sb.String()))
	if err != nil {
		return err
	}

	return pb.fp.Close()
}

func (pb *PbWriter) sortedMethods() []string {
	keys := make([]string, 0, len(pb.methods))
	for k := range pb.methods {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

func (pb *PbWriter) writeHeader(sb *strings.Builder) {
	sb.WriteString("// AUTOMAGICALLY GENERATED by mkpbcopy --- DO NOT EDIT\n\n")
	sb.WriteString(fmt.Sprintf("package %s\n\n", pb.packageName))
}

// PbMehod tracks which methods need a copy method
type PbMethod struct {
	structName string
	fields     []*PbField
}

func (pb *PbMethod) AddField(field *PbField) {
	pb.fields = append(pb.fields, field)
}

func (pb *PbMethod) Write(sb *strings.Builder) {

	sb.WriteString(fmt.Sprintf("func (in *%s) DeepCopy() *%s {\n", pb.structName, pb.structName))
	sb.WriteString(fmt.Sprintf("\tout := &%s{}\n", pb.structName))

	for _, field := range pb.fields {
		field.WriteDeepCopy(sb)
	}

	sb.WriteString("\treturn out\n")
	sb.WriteString("}\n")
	sb.WriteString("\n")

	sb.WriteString(fmt.Sprintf("func (in *%s) ShallowCopy() *%s {\n", pb.structName, pb.structName))
	sb.WriteString(fmt.Sprintf("\tout := &%s{}\n", pb.structName))

	for _, field := range pb.fields {
		field.WriteShallowCopy(sb)
	}

	sb.WriteString("\treturn out\n")
	sb.WriteString("}\n")
	sb.WriteString("\n")
}

// PbCopier reads the pb.go and writes to the copy.go file
type PbCopier struct {
	r *PbReader
	w *PbWriter
}

func NewPbCopier(r *PbReader, w *PbWriter) *PbCopier {
	return &PbCopier{
		r: r,
		w: w,
	}
}

func (pb *PbCopier) MkCopy(structName string) error {
	idx, err := pb.r.FindStruct(structName)
	if err != nil {
		return err
	}

	if pb.w.HasMethod(structName) {
		return nil
	}

	method := pb.w.NewMethod(structName)
	for {
		field, newIdx, err := pb.r.NextField(idx)
		if err != nil {
			return err
		}
		if newIdx < 0 {
			break
		}
		if !field.IsBasicType() {
			realType := pb.r.FindType(field.memberType)
			if len(realType) > 0 && realType != "struct" {
				field.SetRealType(realType)
			}
		}
		if !field.IsBasicType() {
			err := pb.MkCopy(field.memberType)
			if err != nil {
				return err
			}
		}

		method.AddField(field)
		idx = newIdx
	}

	return nil
}

// PbField encabsultes a field in the proto buf
type PbField struct {
	memberName  string
	memberType  string
	realType    string
	isSlice     bool
	isPtr       bool
	isMap       bool
	mapType     string
	sb          *strings.Builder
	indentLevel int
	isShallow   bool
}

func MakeField(memberName string, memberType string) *PbField {
	f := &PbField{
		memberName: memberName,
	}

	if strings.HasPrefix(memberType, "[]") {
		f.isSlice = true
		memberType = memberType[2:]
	}

	if strings.HasPrefix(memberType, "map[") {
		f.isMap = true
		memberType = memberType[4:]
		sl := strings.Split(memberType, "]")
		f.mapType = sl[0]
		memberType = sl[1]
	}

	if strings.HasPrefix(memberType, "*") {
		f.isPtr = true
		memberType = memberType[1:]
	}

	f.memberType = memberType
	f.realType = memberType
	return f
}

func (pb *PbField) SetRealType(realType string) {
	pb.realType = realType
}

func (pb *PbField) IsBasicType() bool {
	switch pb.realType {
	case "string", "bool", "int32", "int64", "float32", "float64":
		return true
	}
	return false
}

func (pb *PbField) IsString() bool {
	return pb.memberType == "string"
}

func (pb *PbField) WriteDeepCopy(sb *strings.Builder) {
	pb.sb = sb
	pb.indentLevel = 1
	pb.isShallow = false
	if pb.isMap {
		pb.nilWrapper(pb.writeMap)
		return
	}
	if pb.isSlice {
		pb.nilWrapper(pb.writeSlice)
		return
	}
	if pb.isPtr {
		pb.nilWrapper(pb.writeMember)
		return
	}
	if pb.IsString() {
		pb.lenWrapper(pb.writeMember)
		return
	}
	pb.writeMember()
}

func (pb *PbField) WriteShallowCopy(sb *strings.Builder) {
	pb.sb = sb
	pb.indentLevel = 1
	pb.isShallow = true
	pb.writeMember()
}

func (pb *PbField) add(line string) {
	pb.sb.WriteString(pb.indent() + line + "\n")
}

func (pb *PbField) nilWrapper(writer func()) {
	pb.add("if in." + pb.memberName + " != nil {")
	pb.indentLevel++
	writer()
	pb.indentLevel--
	pb.add("}")

}

func (pb *PbField) lenWrapper(writer func()) {
	pb.add("if len(in." + pb.memberName + ") > 0 {")
	pb.indentLevel++
	writer()
	pb.indentLevel--
	pb.add("}")

}

func (pb *PbField) writeMap() {
	pb.add("out." + pb.memberName + " = make(map[" + pb.mapType + "]" + pb.ptr() + pb.memberType + ", len(in." + pb.memberName + "))")
	pb.add("for k, v := range in." + pb.memberName + " {")
	pb.indentLevel++
	pb.add("out." + pb.memberName + "[k] = " + pb.copyMethod("v"))
	pb.indentLevel--
	pb.add("}")
}

func (pb *PbField) writeSlice() {
	pb.lenWrapper(pb.writeSliceData)
}

func (pb *PbField) writeSliceData() {
	pb.add("out." + pb.memberName + " = make([]" + pb.ptr() + pb.memberType + ", len(in." + pb.memberName + "))")
	pb.add("for i, v := range in." + pb.memberName + " {")
	pb.indentLevel++
	pb.add("out." + pb.memberName + "[i] = " + pb.copyMethod("v"))
	pb.indentLevel--
	pb.add("}")
}

func (pb *PbField) writeMember() {
	pb.add("out." + pb.memberName + " = " + pb.copyMethod("in."+pb.memberName))
}

func (pb *PbField) indent() string {
	return strings.Repeat("\t", pb.indentLevel)
}

func (pb *PbField) ptr() string {
	if pb.isPtr {
		return "*"
	}
	return ""
}

func (pb *PbField) copyMethod(member string) string {
	if pb.IsBasicType() || pb.isShallow {
		return member
	}
	if !pb.isPtr {
		panic("expected pointer")
	}
	return member + ".DeepCopy()"
}
